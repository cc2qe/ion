#!/bin/bash

# define usage function
usage(){
    echo -e "usage: zapdups [-h] [-uv] [-d delimiter] [-k column] file

zapdups 0.0.1
author: Colby Chiang (cc2qe@virginia.edu)
description: Removes duplicate lines from a file without reordering

positional arguments:
  file\tdefault behavior assumes that duplicate entries
\tare consecutive. If not, use the -u flag. (default is stdin)

optional arguments:
  -h\tshow this message and exit
  -k\tkey column for matches (default: 0, for full line match)
  -d\tinput file delimiter (currently <tab> no matter what you put, sucka)
  -u\tdon't assume duplicates are consecutive (uses more memory)
  -v\tonly print duplicates (duplicates must occur consecutively in file)"

    exit 1
}

# set default values
k=0
delim="\t"
unsorted=false
inverse=false

# process command line args
while getopts huk:d:v opt
do
    case "$opt" in
	h) usage;;
	u) unsorted=true;;
	k) k=$OPTARG;;
	d) delim=$OPTARG;;
	v) inverse=true;;
	\?) usage;;
    esac
done

# set the last arg as the positional arg for input
input=${@:$OPTIND:1}

# if no pipe and no input arg, then print usage and exit
if [[ -t 0 && $input == "" ]]
then
    usage
fi

# if input is unsorted, make an array to store entries
# that have already been visited, and only print if next
# entry is not in the array
if $unsorted
then
    if $inverse
    then
	echo -e "\nERROR: duplicates must occur consecutively to use -v option\n"
	usage
    else
	awk "!_[\$${k}]++" FS="\t" OFS="\t" $input
    fi

# if input file is sorted, only check the previous entry
# for a match
else
    if $inverse
    then
	awk "BEGIN { FIRSTMATCH=0 } { if (\$${k}==PREVK) { if (FIRSTMATCH) { print \$PREVLINE; FIRSTMATCH=0 } print \$0; } else FIRSTMATCH=1; PREVK=\$${k}; PREVLINE=\$0 }" FS="\t" OFS="\t" $input
    else
	awk "{if (\$${k}!=PREV) print \$0; PREV=\$${k}}" FS="\t" OFS="\t" $input
    fi
fi

# exit cleanly
exit 0
