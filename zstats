#!/usr/bin/env python

import argparse, sys
from argparse import RawTextHelpFormatter
from collections import Counter
import math

__author__ = "Colby Chiang (cc2qe@virginia.edu)"
__version__ = "0.0.2"
__date__ = "$Date: 2013-12-07 14:31 $"

# --------------------------------------
# define functions

def get_args():
    parser = argparse.ArgumentParser(formatter_class=RawTextHelpFormatter, description="\
zstats " + __version__ + "\n\
author: " + __author__ + "\n\
description: Calculate basic numeric statistics")
    parser.add_argument('-a', '--abs', action='store_true', help='take absolute values of input before calculating stats')
    parser.add_argument('-p', '--percentile', type=str, default=None, help='comma separated list of percentiles to display (default: 5,25,50,75,95)')
    parser.add_argument('data', nargs='?', type=argparse.FileType('r'), default=None, help='input column of numbers. (default: stdin)')

    # parse the arguments
    args = parser.parse_args()

    # if no input, check if part of pipe and if so, read stdin.
    if args.data == None:
        if sys.stdin.isatty():
            parser.print_help()
            exit(1)
        else:
            args.data = sys.stdin
    return args

# get the number of entries in the set
def countRecords(myCounter):
    numRecords = sum(myCounter.values())
    return numRecords

# sum of the entries
def sumRecords(myCounter):
    mySum = 0.0
    for c in myCounter:
        mySum += c * float(myCounter[c])
    return mySum

# calculate the arithmetic mean, given a counter and the
# length of the feature (chromosome or genome)
# for x percentile, x% of the elements in the set are
# <= the output value
def mean(myCounter):
    # the number of total entries in the set is the
    # sum of the occurrences for each value
    numRecords = countRecords(myCounter)

    # u holds the mean
    u = float

    u = sumRecords(myCounter) / numRecords
    return u

def stdev(myCounter):
    # the number of total entries in the set is the
    # sum of the occurrences for each value
    numRecords = countRecords(myCounter)

    # u holds the mean
    u = mean(myCounter)
    sumVar = 0.0

    # stdev is sqrt(sum((x-u)^2)/#elements)
    for c in myCounter:
        sumVar += myCounter[c] * (c - u)**2
    myVariance = float(sumVar) / numRecords
    stdev = myVariance**(0.5)
    return stdev

def variance(myCounter):
    # the number of total entries in the set is the
    # sum of the occurrences for each value
    numRecords = countRecords(myCounter)

    # u holds the mean
    u = mean(myCounter)
    sumVar = 0.0

    # stdev is sqrt(sum((x-u)^2)/#elements)
    for c in myCounter:
        sumVar += myCounter[c] * (c - u)**2
    myVariance = float(sumVar) / numRecords
    return myVariance

# the geometric mean is the nth root of the product
# of n values. Here we'll use a logrithmic representation
# so we don't have to deal with rounding error from large
# products.
# geo_mean = exp(arithMean(ln(a_i))
def geoMean(myCounter):
    # if there is a zero in the data, then geometric
    # mean is undefined
    if 0.0 in list(myCounter):
        return 'undef (zero found in data)'

    numRecords = countRecords(myCounter)

    # counter for the log values
    logCounts = Counter()

    # store the log counts 
    for c in myCounter:
        if c < 0:
            return 'undef (negative number found in data)'
        logCounts[math.log(c)] += myCounter[c]
            
    # the mean of the log values
    meanLog = mean(logCounts)

    return math.exp(meanLog)


# calculate percentiles from the depth counter.
def percentile(myCounter, p):
    p = float(p)

    #length is the number of bases we're looking at
    numEntries = countRecords(myCounter)

    # the ordinal value of the output element
    limit = int(round(p/100 * numEntries + 0.5))

    # a list of the values, sorted smallest to largest
    # note that this list contains unique elements only
    valueList = list(myCounter)
    valueList.sort()
    numValues = len(valueList)

    # the number of entries through the set
    # we've gone
    b = 0

    # iterator i
    i = 0
    while b < limit:
        # if i is greater than numValues, just return the largest
        if i == (numValues - 1):
            break

        myValue = valueList[i]

        # myCounter[myValue] is the number of entries
        # that have myValue
        b += myCounter[myValue]
        i += 1

    v = valueList[i]
    return v

# median is approx 50th percentile, except when it is between
# two values in which case it's the mean of them.
def median(myCounter):
    #length is the number of bases we're looking at
    numEntries = countRecords(myCounter)

    # the ordinal value of the middle element
    limit = int(0.5 * numEntries)

    # a list of the values, sorted smallest to largest
    # note that this list contains unique elements only
    valueList = list(myCounter)
    valueList.sort()
    numValues = len(valueList)

    # the number of entries through the set
    # we've gone
    b = 0

    # iterator i
    i = 0
    while b <= limit:
        # if i is greater than numValues, just return the largest
        if i == (numValues - 1):
            v = valueList[i]
            break

        # get the value at that ordinal value
        myValue = valueList[i]


        if b == limit:

            # if there are an odd number of entries, then just return this value          
            if numEntries % 2:
                v = valueList[i]
            # else there are an even number of entries. So take the average of
            # the bth value and the one above it.
            else:
                # check whether this value is unique or not.
                if myCounter[myValue] == 1:
                    v = (valueList[i] + valueList[i+1]) / 2.0
                # if the limit is on the rightmost edge of a valueList
                elif limit == prev_b + b:
                    v = (valueList[i] + valueList[i+1]) / 2.0
                else:
                    v = valueList[i]

        # store the previous value of b in case the next value is the median
        prev_b = b
        # myCounter[myValue] is the number of entries
        # that have myValue
        b += myCounter[myValue]
        i += 1

    return v



    # length is the number of bases we're looking at
    numEntries = countRecords(myCounter)
    
    # a list of the values, sorted smallest to largest
    valueList = list(myCounter)
    valueList.sort()

    if numEntries % 2:
        m = valueList[int(0.5 * numEntries - 0.5)]
    else:
        leftIdx = int(0.5 * numEntries)
        m = (valueList[leftIdx - 1] + valueList[leftIdx]) / 2.0
    return m
    
def mode(myCounter):
    return myCounter.most_common()[0]

def antimode(myCounter):
    return myCounter.most_common()[:-2:-1][0]

def minimum(myCounter):
    return min(list(myCounter))

def maximum(myCounter):
    return max(list(myCounter))
    

# primary function
def calcStats(data, absolute, pTile):
    # Each entry in valueCounts is a value, and its count is
    # the number of instances of that value observed in the dataset.
    # So valueCount[5] is the number of times 5 has been seen in the data.
    valueCounts = Counter()
    
    for line in data:
        lineVal = float(line.strip())
        
        # if absolute flag, then absolutize the lineVal
        if absolute:
            lineVal = abs(lineVal)
        
        # add the lineVal to the counter
        valueCounts[lineVal] += 1
    
    # print the formatted output.
    print 'num records:\t%s' % countRecords(valueCounts)
    print 'sum:\t\t%s' % sumRecords(valueCounts)
    print 'arith. mean:\t%s' % mean(valueCounts)
    print 'geo. mean:\t%s' % geoMean(valueCounts)
    print 'median:\t\t%s' % median(valueCounts)
    print 'min:\t\t%s' % minimum(valueCounts)
    print '5 %%tile:\t%s' % percentile(valueCounts, 5)
    print 'Q1:\t\t%s' % percentile(valueCounts, 25)
    print 'Q2:\t\t%s' % percentile(valueCounts, 50)
    print 'Q3:\t\t%s' % percentile(valueCounts, 75)
    print '95 %%tile:\t%s' % percentile(valueCounts, 95)
    if pTile:
        for myPtile in pTile.split(','):
            pfloat = float(myPtile)
            if pfloat >= 100 or pfloat < 0:
                print "Error: percentile %s is not between 0 and 100" % myPtile
                continue
            print '%s %%tile:\t%s' % (myPtile, percentile(valueCounts, pfloat))
    print 'max:\t\t%s' % maximum(valueCounts)
    print 'mode:\t\t%s (N=%s)' % mode(valueCounts)
    print 'anti-mode:\t%s (N=%s)' % antimode(valueCounts)
    print 'stdev:\t\t%s' % stdev(valueCounts)
    print 'variance:\t%s' % variance(valueCounts)

    return

# --------------------------------------
# main function

def main():
    # parse the command line args
    args = get_args()

    # store into global values
    data = args.data
    absolute = args.abs
    pTile = args.percentile
    
    # call primary function
    calcStats(data, absolute, pTile)
    
    # close the file
    data.close()

# initialize the script
if __name__ == '__main__':
    sys.exit(main())
